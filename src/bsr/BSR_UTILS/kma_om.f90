!======================================================================
!     UTILITY  kma_om
!======================================================================
!
!     K-matrix  --> OMEGA-matrix, T-matrix
!
!     zarm.kma  --> zarm.om,  zarm.tma     (default names)
!
!     Call:  kma_om
!
!     The file zarm.kma (the collection of K-matrixes) is considered as
!     the main data-bank for given scattering calculations.
!     The files with corresponding T-matrices or OMEGA-values are
!     generated by this utility (if you beleive that there is some
!     descripancies betweem already existing .kma, .tma or .om files)
!
!     This utility also provides list of energies (in kma_om.log)
!     for which the collection of K-matrixes is incomplete or dublicated
!
!======================================================================

      Use target; Use channels

      Implicit real(8) (a-h,o-z)

      Parameter (ke=5000)

      Real(8), allocatable :: e(:), kma(:), tmar(:),tmai(:), om(:)
      Real(8), allocatable :: fl(:,:)
      Integer, allocatable :: npl(:), ipe(:)
      Integer, allocatable :: ipl(:,:)

      Logical EX

! ... files:

      Character(20) :: param = 'target';     Integer :: nup = 1
      Character(20) :: kname = 'zarm.kma';   Integer :: nuk = 2
      Character(20) :: oname = 'zarm.om';    Integer :: nuo = 3
      Character(20) :: tname = 'zarm.tma';   Integer :: nut = 4
      Character(20) :: nname = 'zarm.kma_c';   Integer :: nun = 5
      Character(20) :: qname = 'zarm.om_par';  Integer :: nuq = 11

      Character(20) :: logf  = 'kma_om.log'; Integer :: pri = 6
      Character(20) :: AF = ' ', label = ' '

      Integer :: nua=99   ! scratch file

      Call Inf_sub

      Call Read_aarg('label',label)

      if(len_trim(label).gt.0) then
        kname = 'zarm.kma'//trim(label)
        oname = 'zarm.om'//trim(label)
        tname = 'zarm.tma'//trim(label)
        nname = 'zarm.kma_c'//trim(label)
        qname = 'zarm.om_par'//trim(label)
        logf =  'kma_om.log'//trim(label)
      end if
!----------------------------------------------------------------------
! ... target information:

      Inquire(file=param,EXIST=EX)
      if(.not.EX) Stop ' No target file: run h_targb ! '
      Open(nup,file=param);
      Call R_target(nup)
      Call R_channels(nup)
      close(nup)
      ion = nz-nelc; zion=1.d0; if(ion.gt.1) zion=ion*ion
      E1 = etarg(1); etarg = (etarg-E1)*2.d0

      Inquire(file=kname,EXIST=EX)
      if(.not.EX) Stop ' No K_matrix file zarm.kma !'
      Open(nuk,file=kname,status='OLD')

      Open(nut,file=tname)
      Open(nuo,file=oname)
      Open(nun,file=nname)
      Open(nuq,file=qname)

      mdim=mch*(mch+1)/2; Allocate(kma(mdim),tmar(mdim),tmai(mdim))

      mom=ntarg*(ntarg+1)/2; Allocate(om(mom))

      np = ntarg
      ni = ntarg

!----------------------------------------------------------------------
! ... find energies:

      me = ke; Allocate(e(me))
      ne=0
    1 read(nuk,*,end=2) e1,nopen,ntr,ilsp
      read(nuk,*) kma(1:ntr)
      if(ntr.eq.0) go to 1

      ie=0
      Do i=1,ne; if(e1.ne.e(i)) Cycle; ie=i; Exit; End do

      if(ie.eq.0) then; ne=ne+1; e(ne)=e1;  end if

      if(ne.eq.me) then
       open(nua,form='UNFORMATTED',status='SCRATCH')
       rewind(nua); write(nua) (e(i),i=1,ne)
       Deallocate(e); me=me+ke; Allocate(e(me))
       rewind(nua); read(nua) (e(i),i=1,ne)
      end if

      go to 1
    2 write(*,*) ' ne =',ne

      Allocate(fl(mom,ne),ipl(nlsp,ne),npl(ne)); fl=0.d0; ipl=0; npl=0

!----------------------------------------------------------------------
! ... read and transform K-matrices:

      rewind(nuk)
    3 read(nuk,*,end=4) ee,nopen,ntr,ilsp
      read(nuk,*) kma(1:ntr)
      if(ntr.eq.0) go to 3

if(ntr.ne.nopen*(nopen+1)/2) Stop 'nopen<>ntr'
if(ilsp.gt.nlsp) then; write(*,*) ilsp,nlsp; Stop 'ilsp >nlsp'; end if
if(ilsp.lt.0) then; write(*,*) ilsp,nlsp; Stop 'ilsp < 0'; end if
if(nopen.gt.nch(ilsp)) Stop 'nopen > nch(ilsp)'

      ie=0
      Do i=1,ne; if(ee.ne.e(i)) Cycle; ie=i; Exit; End do
      if(ie.eq.0) Stop 'unknown energy'

      ipl(ilsp,ie) = ipl(ilsp,ie) + 1

      if(ipl(ilsp,ie).gt.1) go to 3

! ... checked K-matrix:

      write(nun,'(F10.6,3i8)') ee,nopen,ntr,ilsp
      write(nun,'(6D16.8)') (kma(i),i=1,ntr)

! ... T-matrix:

      Call kma_tma (nopen,kma,tmar,tmai)

! ... partial omega:

      Call tma_om (ilsp,nopen,nom,tmar,tmai,om)

      if(nom.gt.mom) Stop ' nom -?'

      fl(1:nom,ie) = fl(1:nom,ie) + om(1:nom)
      if(nom.gt.npl(ie)) npl(ie) = nom

      write(nut,'(F10.6,3i8)') ee,nopen,ntr,ilsp
      write(nut,'(6D16.8)') (tmar(i),tmai(i),i=1,ntr)

!      kopen = iptar(ilsp,nopen)

      write(nuq,'(F10.6,6i8,a)')  e(ie),ilsp,nom
      write(nuq,'(5D16.8)') (om(i),i=1,nom)

      go to 3
    4 Continue
      Close(nuk); Close(nut)

! ... energy order:

      Allocate(ipe(ne));  Call SortR(ne,E,ipe)

! ... output omega:

      Do je=1,ne; ie=ipe(je)

       if(nz.eq.nelc) then
        ntr = npl(ie)
        write(nuo,'(F10.6,i8)')  e(ie),ntr
        write(nuo,'(5D16.8)') (fl(i,ie),i=1,ntr)
       else
        io=IOPEN(ntarg,e(ie),etarg)
        ntr = io*(io-1)/2
        write(nuo,'(F10.6,i8)')  e(ie),ntr
        write(nuo,'(5D16.8)') ((fl(i*(i-1)/2+j,ie),j=1,i-1),i=2,io)
       end if

      End do

! ... log information:

      Open(pri,file=logf)

      k = 0
      write(pri,*) 'Absent:'
      Do ie=1,ne; Do ilsp=1,nlsp
       if(ipl(ilsp,ie).gt.0) Cycle
       if(jopen(e(ie),ilsp).eq.0) Cycle
       write(pri,'(f10.6,i5)') E(ie),ilsp
       k = k + 1
      End do; End do

      write(pri,*) 'In excess:'
      Do ie=1,ne; Do ilsp=1,nlsp
       if(ipl(ilsp,ie).le.1) Cycle
       write(pri,'(f10.6,2i5)') E(ie),ilsp,ipl(ilsp,ie)
       k = k + 1
      End do; End do

      if(k.gt.0) close(nun,STATUS='DELETE')

      End  ! utility kma_om


!======================================================================
      Subroutine tma_om (ilsp,nopen,nom,tmar,tmai,om)
!======================================================================

      Use target; Use channels

      Implicit none

      Integer(4), Intent(in) :: ilsp,nopen
      Integer(4), Intent(out) :: nom
      Real(8), intent(in), dimension(*) :: tmar,tmai
      Real(8), intent(out), dimension(*) :: om

      Integer(4) :: i,j, ij, itr,itr1,itr2
      Real(8) :: g,s

      g = (2*lpar(ilsp)+1) * iabs(ispar(ilsp)) / 2.d0
      if(ispar(ilsp).eq.0) g = (lpar(ilsp)+1)/2.d0

      i=iptar(ilsp,nopen);  nom=(i+1)*i/2; om(1:nom)=0.d0

      Do i=1,nopen; itr1=iptar(ilsp,i)
       Do j=i,nopen; itr2=iptar(ilsp,j)
        ij=(j-1)*j/2+i; itr=(itr2-1)*itr2/2+itr1
        s = (tmar(ij)*tmar(ij)+tmai(ij)*tmai(ij))*g
        if(itr1.eq.itr2.and.i.ne.j) s = s + s
        om(itr) = om(itr) + s
       End do
      End do

      End Subroutine tma_om



!======================================================================
      Subroutine kma_tma (n,kma,tr,ti)
!======================================================================
!     T = 1 - S = -2i K/(1-iK) = (2K^2 - 2iK) / (1+K^2) = -2i [P + i Q]
!
!     P = K /(..);   Q = -K^2/(..) = -(1 - 1/(..))= 1/(..)-1
!
!     n - number of open channels
!----------------------------------------------------------------------
      Implicit real(8) (a-h,o-z)
      Integer, intent(in)  :: n
      Real(8), intent(in)  :: kma(*)
      Real(8), intent(out) :: tr(*),ti(*)
      Real(8) :: AK(n,n),AK1(n,n),AK2(n,n)

      Do i=1,n                               !   AK --> K-matrix
       Do j=1,i
        ij=(i-1)*i/2+j; AK(i,j)=kma(ij); AK(j,i)=kma(ij)
       End do
      End do

      Do i=1,n                               !   AK1 --> 1 + K^2
       Do j=i,n                              !   AK2 -->     K^2
        x=SUM(AK(i,:)*AK(:,j))
        AK2(i,j)=x; AK2(j,i)=x; AK1(i,j)=x; AK1(j,i)=x
        if(i.eq.j) AK1(i,i)=AK1(i,i)+1
       End do
      End do

      Call Inv(n,n,AK1)                      !  AK1 --> AK1^-1

      Do i=1,n
       Do j=i,n
        x=SUM(AK2(i,:)*AK1(:,j))
        y=SUM(AK (i,:)*AK1(:,j))
        ij=(j-1)*j/2+i; TR(ij)= +2.d0*x; TI(ij)= -2.d0*y
       End do
      End do

      End Subroutine kma_tma


!======================================================================
      Subroutine inf_sub
!======================================================================
!     provide screen information about add_farm utility
!----------------------------------------------------------------------

      Character :: A

      iarg = command_argument_count()
      if(iarg.eq.0) Return
      Call GET_COMMAND_ARGUMENT(1,A)
      if(A.ne.'?'.and.A.ne.'!') Return

      write(*,'(a)') &
'                                                                       ',&
'     kma_om recalculates T-matrix and OMEGA data  based on the         ',&
'     K-matrix elements                                                 ',&
'                                                                       ',&
'        zarm.kma + target  ->  zarm.tma, zarm.om, zarm.om_par          ',&
'                                                                       ',&
'     We used fixed default names.                                      ',&
'                                                                       ',&
'     Call as:  kma_om                                                  ',&
'                                                                       ',&
'     kma_om.log contains which partial wave data are absent or in access ',&
'     If such situation are happened, program  creates corrected file   ',&
'     "zarm.kma_c" where the enegies with absent or access are omitted  ',&
'                                                                       '
      Stop ' '

      End Subroutine inf_sub

